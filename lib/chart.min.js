class AdvancedChart {
    constructor(ctx) {
        this.ctx = ctx.getContext('2d');
        this.width = ctx.width;
        this.height = ctx.height;
        this.colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', 
            '#DDA0DD', '#98D8C8', '#F7DC6F', '#AED6F1', '#F8C471'
        ];
        this.gradients = [
            ['#FF6B6B', '#FF8E8E'],
            ['#4ECDC4', '#6ED7D0'],
            ['#45B7D1', '#67C3D7'],
            ['#96CEB4', '#A8D5C0'],
            ['#FFEAA7', '#FFE082']
        ];
    }

    // Enhanced Pie Chart with animations and labels
    drawPieChart(data, options = {}) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 40;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const total = data.values.reduce((sum, val) => sum + val, 0);
        let currentAngle = -Math.PI / 2; // Start from top
        
        // Draw slices
        data.values.forEach((value, index) => {
            const sliceAngle = (value / total) * 2 * Math.PI;
            const percentage = ((value / total) * 100).toFixed(1);
            
            // Create gradient
            const gradient = ctx.createLinearGradient(
                centerX - radius, centerY - radius,
                centerX + radius, centerY + radius
            );
            gradient.addColorStop(0, this.colors[index % this.colors.length]);
            gradient.addColorStop(1, this.lightenColor(this.colors[index % this.colors.length], 20));
            
            // Draw slice
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
            ctx.lineTo(centerX, centerY);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add stroke
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw labels
            if (percentage > 5) { // Only show labels for slices > 5%
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add text shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 2;
                ctx.fillText(percentage + '%', labelX, labelY);
                ctx.shadowBlur = 0;
            }
            
            currentAngle += sliceAngle;
        });
        
        // Draw legend
        this.drawLegend(data.labels, 20, 20);
    }

    // Enhanced Bar Chart with gradients and animations
    drawBarChart(data, options = {}) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const padding = 60;
        const chartWidth = canvas.width - padding * 2;
        const chartHeight = canvas.height - padding * 2;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const maxValue = Math.max(...data.values);
        const barWidth = chartWidth / data.values.length;
        const scale = chartHeight / maxValue;
        
        // Draw grid lines
        this.drawGrid(padding, chartWidth, chartHeight, maxValue);
        
        // Draw bars
        data.values.forEach((value, index) => {
            const barHeight = value * scale;
            const x = padding + index * barWidth + barWidth * 0.1;
            const y = canvas.height - padding - barHeight;
            const actualBarWidth = barWidth * 0.8;
            
            // Create gradient
            const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
            gradient.addColorStop(0, this.colors[index % this.colors.length]);
            gradient.addColorStop(1, this.darkenColor(this.colors[index % this.colors.length], 20));
            
            // Draw bar with rounded corners
            this.drawRoundedRect(ctx, x, y, actualBarWidth, barHeight, 4);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add stroke
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw value labels
            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('₹' + this.formatValue(value), x + actualBarWidth / 2, y - 8);
            
            // Draw category labels
            ctx.fillStyle = '#4a5568';
            ctx.font = '10px Arial';
            ctx.save();
            ctx.translate(x + actualBarWidth / 2, canvas.height - padding + 15);
            ctx.rotate(-Math.PI / 6);
            ctx.textAlign = 'right';
            ctx.fillText(data.labels[index], 0, 0);
            ctx.restore();
        });
        
        // Draw axes
        this.drawAxes(padding, chartWidth, chartHeight);
    }

    // Line Chart with smooth curves
    drawLineChart(data, options = {}) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const padding = 60;
        const chartWidth = canvas.width - padding * 2;
        const chartHeight = canvas.height - padding * 2;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const maxValue = Math.max(...data.values);
        const minValue = Math.min(...data.values);
        const valueRange = maxValue - minValue || 1;
        
        // Draw grid
        this.drawGrid(padding, chartWidth, chartHeight, maxValue);
        
        // Calculate points
        const points = data.values.map((value, index) => ({
            x: padding + (index / (data.values.length - 1)) * chartWidth,
            y: canvas.height - padding - ((value - minValue) / valueRange) * chartHeight
        }));
        
        // Draw area under curve
        if (points.length > 1) {
            const gradient = ctx.createLinearGradient(0, padding, 0, canvas.height - padding);
            gradient.addColorStop(0, 'rgba(67, 183, 209, 0.3)');
            gradient.addColorStop(1, 'rgba(67, 183, 209, 0.05)');
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, canvas.height - padding);
            points.forEach(point => ctx.lineTo(point.x, point.y));
            ctx.lineTo(points[points.length - 1].x, canvas.height - padding);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
        }
        
        // Draw smooth line
        if (points.length > 1) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                const prevPoint = points[i - 1];
                const currentPoint = points[i];
                const nextPoint = points[i + 1];
                
                if (nextPoint) {
                    const cp1x = prevPoint.x + (currentPoint.x - prevPoint.x) * 0.5;
                    const cp1y = prevPoint.y;
                    const cp2x = currentPoint.x - (nextPoint.x - currentPoint.x) * 0.5;
                    const cp2y = currentPoint.y;
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, currentPoint.x, currentPoint.y);
                } else {
                    ctx.lineTo(currentPoint.x, currentPoint.y);
                }
            }
            
            ctx.strokeStyle = '#43B7D1';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // Draw data points
        points.forEach((point, index) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#43B7D1';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Value labels
            ctx.fillStyle = '#2d3748';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('₹' + this.formatValue(data.values[index]), point.x, point.y - 12);
        });
        
        // Draw axes
        this.drawAxes(padding, chartWidth, chartHeight);
        
        // Draw x-axis labels
        ctx.fillStyle = '#4a5568';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        data.labels.forEach((label, index) => {
            const x = padding + (index / (data.labels.length - 1)) * chartWidth;
            ctx.fillText(label, x, canvas.height - padding + 20);
        });
    }

    // Horizontal Bar Chart
    drawHorizontalBarChart(data, options = {}) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        const padding = 80;
        const chartWidth = canvas.width - padding * 2;
        const chartHeight = canvas.height - padding * 2;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const maxValue = Math.max(...data.values);
        const barHeight = chartHeight / data.values.length;
        
        // Draw bars
        data.values.forEach((value, index) => {
            const barWidth = (value / maxValue) * chartWidth;
            const y = padding + index * barHeight + barHeight * 0.1;
            const actualBarHeight = barHeight * 0.8;
            
            // Create gradient
            const gradient = ctx.createLinearGradient(padding, y, padding + barWidth, y);
            gradient.addColorStop(0, this.colors[index % this.colors.length]);
            gradient.addColorStop(1, this.lightenColor(this.colors[index % this.colors.length], 20));
            
            // Draw bar
            this.drawRoundedRect(ctx, padding, y, barWidth, actualBarHeight, 4);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw category label
            ctx.fillStyle = '#2d3748';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(data.labels[index], padding - 10, y + actualBarHeight / 2 + 4);
            
            // Draw value label
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('₹' + this.formatValue(value), padding + barWidth / 2, y + actualBarHeight / 2 + 4);
        });
        
        // Draw axes
        this.drawAxes(padding, chartWidth, chartHeight);
    }

    // Utility methods
    drawGrid(padding, chartWidth, chartHeight, maxValue) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        
        ctx.strokeStyle = 'rgba(226, 232, 240, 0.8)';
        ctx.lineWidth = 1;
        
        // Horizontal grid lines
        for (let i = 0; i <= 5; i++) {
            const y = canvas.height - padding - (i / 5) * chartHeight;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(padding + chartWidth, y);
            ctx.stroke();
            
            // Y-axis labels
            ctx.fillStyle = '#718096';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('₹' + this.formatValue((i / 5) * maxValue), padding - 10, y + 3);
        }
    }

    drawAxes(padding, chartWidth, chartHeight) {
        const ctx = this.ctx;
        const canvas = ctx.canvas;
        
        ctx.strokeStyle = '#4a5568';
        ctx.lineWidth = 2;
        
        // Y-axis
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.stroke();
        
        // X-axis
        ctx.beginPath();
        ctx.moveTo(padding, canvas.height - padding);
        ctx.lineTo(padding + chartWidth, canvas.height - padding);
        ctx.stroke();
    }

    drawLegend(labels, x, y) {
        const ctx = this.ctx;
        const boxSize = 12;
        const spacing = 18;
        
        labels.forEach((label, index) => {
            const currentY = y + index * spacing;
            
            // Draw color box
            ctx.fillStyle = this.colors[index % this.colors.length];
            ctx.fillRect(x, currentY, boxSize, boxSize);
            
            // Draw label
            ctx.fillStyle = '#2d3748';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(label, x + boxSize + 8, currentY + boxSize - 2);
        });
    }

    drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }

    formatValue(value) {
        if (value >= 100000) {
            return (value / 100000).toFixed(1) + 'L';
        } else if (value >= 1000) {
            return (value / 1000).toFixed(1) + 'K';
        }
        return value.toString();
    }

    lightenColor(color, percent) {
        const num = parseInt(color.slice(1), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
    }

    darkenColor(color, percent) {
        const num = parseInt(color.slice(1), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 +
            (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 +
            (B > 255 ? 255 : B < 0 ? 0 : B)).toString(16).slice(1);
    }
}

// Make it globally available
window.Chart = AdvancedChart;